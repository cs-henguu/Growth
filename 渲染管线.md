# 渲染管线

一般是指将3D事物呈现在2D屏幕上的过程。2D屏幕上的像素和经过渲染管线出来的2D坐标还不一样，像素是对2D坐标的一个近似，取决于屏幕硬件的分辨率。

渲染管线接受一组3D坐标，将它们转化为屏幕上的**2D像素**，并给每个**像素点着色**。

处理这个渲染管线的硬件是GPU，GPU上运行着各种并行的小程序来进行处理，这些小程序叫**着色器**。

流程：

- 首先是CPU将网格和材质数据经过视锥体剔除等操作交给GPU，调用DrawCall。顶点（包括顶点坐标，法线，纹理坐标，颜色值等顶点属性）集合组成一个**顶点数据**数组，组成方式是通过图元，即一个图元为一组，图元包括点、线、线条、三角面等。

- 顶点数据按照图元形式存储，必然导致有大部分图元的顶点是共用的，重复存储浪费内存，解决办法是 **顶点缓冲对象VBO**和**索引缓冲对象EBO**：定义一个所有的不重复顶点数组，再定义一个图元顶点的索引数组，根据

- 然后**顶点着色器**进行坐标变换，将输入的顶点坐标从局部空间通过世界坐标、观察坐标、裁剪坐标，转换到NDC标准化设备坐标空间(-1,1)。可能会进行顶点着色，如平面着色，高洛德着色等。
  - **坐标变换**：从建模软件得到的是模型的**局部坐标**，局部坐标通过**模型矩阵(Model Matrix)**变换到**世界坐标**，世界坐标通过相机的**观察矩阵(View Matrix)**变换到**观察坐标**，观察坐标经过**投影矩阵(Projection Matrix)**变换到**裁剪坐标**，裁剪坐标经过**透视除法**得到NDC坐标，NDC通过视口变换到窗口进行显示。
    - 模型矩阵 Model Matrix：在世界空间上对物体进行平移、旋转和缩放。如果物体变换有非均匀缩放，那么简单地乘以模型矩阵会导致法线不正确，还应该适用矩阵的逆来变换法线。
    - 观察矩阵 View Matrix：相机的LookAt矩阵，利用相机的位置坐标和方向向量通过叉乘计算得到
    - 视锥体：正交投影比较简单，直接除以1即可。透视投影需要近大远小，四个参数：fov，宽高比，近平面和远平面。首先根据fov和近平面的距离得到近平面的高度，再通过宽高比可以得到近平面的宽度，远平面同理。然后根据相似三角形以z为基准，可以依次得到xy坐标在相机近平面上的投影坐标。
    - 透视除法：通过将视锥体里面的坐标都除以w分量，将坐标映射到(-1，1)的立方体中，即NDC坐标空间
  
- 然后是**曲面细分**，对三角面进行细分，增加物体表面的三角面数量。是一个选配阶段，包括外壳着色器、镶嵌器和域着色器。使离相机近的物体细节更加丰富，远离相机的物体细节更少。

- 然后是**几何着色器**，也是选配阶段，其输入是基本的图元，将输入的图元扩展为多边形。

- 然后是**图元组装**，将输入的顶点组装成特定的图元，会进行裁剪和背面剔除等优化，减少进入光栅化的图元的数量。

- **光栅化**：图元装配和三角形遍历。现在物体坐标已经从局部空间转换到了视口坐标，光栅化会将连续的视口坐标近似为离散的屏幕像素坐标。确定图元所覆盖的像素片段，利用顶点属性插值计算出片段属性，送到片段着色器进行上色。

- **片段着色器**：决定像素的颜色，这个阶段会进行光照计算和阴影处理。

- **测试混合阶段**：测试包括Alpha测试、模板测试、深度测试等。没有通过测试的片段被丢弃，通过测试的片段进入混合阶段。Alpha混合根据片段的Alpha值进行混合，产生半透明效果。透明效果要严格遵循**画家算法**：从远处到近处依次绘制产生半透明效果。

  模板测试：画物体轮廓、阴影体积渲染实时阴影。

  - **画家算法：**先绘制所有的不透明物体，对所有的透明物体进行排序，按顺序绘制所有透明的物体。
  - **排序透明物体**：简单的做法是根据物体与相机之间的距离排序，先渲染排序较远的物体，再渲染较近的物体。这个做法的问题在于它是从物体层面考虑渲染顺序的而不是像素层面，因此只有在所有物体严格的堆叠时才使用。，

# 阴影

## 阴影贴图

流程：走两遍渲染，第一遍渲染生成从光源位置（点光源是将其当做相机进行light_MVP变换，平行光则是直接映射）生成一张深度贴图，又叫阴影贴图。第二遍渲染则是正常渲染，但是多了一个在片段着色器中判断该片段是否处在阴影中的步骤。判断方法是根据第一遍渲染的阴影贴图，根据顶点着色器里面的light_MVP变换之后的二维坐标在阴影贴图上索引，判断当前片段在阴影贴图上深度值是否大于最小深度值，如果大于则证明该片段没有被光源照射到，即处于阴影之中。

```c++
// 1. 首先渲染深度贴图
glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glClear(GL_DEPTH_BUFFER_BIT);
ConfigureShaderAndMatrices();
RenderScene();
glBindFramebuffer(GL_FRAMEBUFFER, 0);
// 2. 像往常一样渲染场景，但这次使用深度贴图
glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
ConfigureShaderAndMatrices();
glBindTexture(GL_TEXTURE_2D, depthMap);
RenderScene();
```

问题：

- 第二遍渲染中，如何根据light_MVP得到某个片段的深度贴图坐标？

  第二遍渲染时，在顶点着色器中计算顶点在光空间的坐标，并将该坐标通过内置数据结构一起传到片段着色器。正常渲染流程中的透视除法是默认进行的，因此光空间的坐标需要自己额外进行一次透视除法，即 *vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;*，将其转换到NDC坐标。由于深度贴图的深度值和索引在（0，1），所以还需要将坐标变换到（0，1） *projCoords = projCoords * 0.5 + 0.5;*，然后就可以通过比较深度值判断是否在阴影中。

  ```glsl
  // 顶点着色器中
  out VS_OUT {
      vec3 FragPos;
      vec3 Normal;
      vec2 TexCoords;
      vec4 FragPosLightSpace;	// 光空间的坐标
  } vs_out;
  
  // 片段着色器中
  float ShadowCalculation(vec4 fragPosLightSpace)
  {
      // 执行透视除法
      vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
      // 变换到[0,1]的范围
      projCoords = projCoords * 0.5 + 0.5;
      // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
      float closestDepth = texture(shadowMap, projCoords.xy).r; 
      // 取得当前片段在光源视角下的深度
      float currentDepth = projCoords.z;
      // 检查当前片段是否在阴影中
      float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;
  
      return shadow;
  }
  ```

- 为什么要加阴影偏移？

  因为阴影失真。阴影贴图的分辨率是有限的，会出现多个片段共用阴影贴图上的一个索引的问题，尤其是在光线打到平面上时，该平面上的某几个相邻片段共用一个阴影贴图像素点，从而出现本不该是阴影的某个片段反而被计算出来了阴影。解决思路是给深度贴图的最小深度值加一个微小的偏移，可以根据表面朝向光线的角度确定偏移值的大小。

## 非定向光阴影

上面生成的只是定向光阴影，即light_MVP矩阵的确定是一个单一方向，生成的深度贴图也只是这一个方向的贴图。

万向阴影贴图是生成一个六个面的立方体深度贴图，从而实现了从光源的各个方向看过去都有阴影贴图，全方向都能产生阴影的效果。

为了避免渲染六次得到一个立方体深度贴图，使用**几何着色器**可以一遍pass得到，做法是：暂时不知道，也没尝试。

- 如何在第二遍渲染中进行光空间的变换？

  为光源的每个方向提供一个不同的视图矩阵，用lookAt创建6个观察方向，得到6个不同的光空间变换矩阵。顶点着色器简单地把坐标变换到世界空间，交给几何着色器将世界空间的顶点通过内置变量发送到立方体贴图的每个面，

## 软影

### 1. PCF

硬阴影的方法是第二遍渲染时的片段和深度贴图进行一对一索引、比较。PCF的想法是第二遍渲染的片段与深度贴图进行一对多的索引，计算得到多个索引结果的平均值，确定阴影的软硬程度。

选择样本可以更优化：多个方向随机采样，而不是单纯地从邻近像素点采样，同时剔除彼此接近的子方向的样本。还可以根据相机与片段的距离改变采样的半径。

### 2. PCSS

是PCF的改进版本，关键在于采样点的选择更加精准。为了改进PCF采样半径的确定。

步骤：

- 确定遮挡距离，即shading point这个点到底能被面光源的多大部分照射到，这个决定了shading point的阴影软硬程度。
- 根据遮挡距离计算采样点的滤波半径
- 进行PCF软影绘制



shading point和面光源（光源相机的近平面）处处连线可以在阴影贴图上划出一个区域，计算这个区域的哪些片段被遮挡，哪些片段没有被遮挡，从而确定shading point处的遮挡程度即软影程度。在判断片段遮挡时，要使用加了偏移之后的采样深度去判断，否则软影边缘会出现跳变，这是因为不加偏移的话，处在硬阴影之外的那些点的遮挡深度一定为0，从而导致很多采样点边缘出现跳变。

根据平均遮挡距离确定采样半径：首先将shading point 与光源的距离转换到世界坐标下的距离，然后根据平均遮挡深度将blocker与光源的距离转换为世界坐标下的距离，再根据相似三角形计算世界坐标下的采样半径，再将这个采样半径转换为阴影贴图纹理上的采样半径（0，1）。

改进：只对半影区域做平均遮挡深度的计算，节省性能开销。第一遍pass时生成一张Mask标记半影区域，第二遍pass时根据Mask只对半影的像素片段做遮挡计算，其他像素片段直接返回阴影值0或1。Mask标记的做法是将直接生成的阴影贴图的每4*4个像素一同计算然后每16个像素被一个像素代表是否是半影。第二遍pass访问深度缓冲即阴影贴图时依然按照原分辨率即16个像素的分辨率去进行。

### 3. CSM

大场景中阴影贴图精度问题。大场景在渲染阴影时往往是给一张大阴影贴图，如果阴影贴图的分辨率过大，则GPU吃不消，过小则会出现锯齿。

早期的一种思路是增大屏幕中心也就是玩家附近的阴影贴图的像素比例来减少锯齿。

基本思想是：近处物体占据大部分屏幕像素，应该匹配更高精度（不是整个阴影贴图的分辨率而是像素与阴影贴图上的片段深度值的映射比例，精度越低则像素共用一个深度值就越多）的阴影贴图。

做法：将场景按照远近进行划分，比如按照主相机的深度方向进行划分成不同的子视锥体，每一级不同的视锥体覆盖不同的shadow map。



# 空间加速结构



## 包围盒



## 八叉树

# 经验光照模型

## Phong模型

经验模型

环境光+漫反射+镜面光

环境光 ambient参数

漫反射系数是入射光与法线夹角

镜面光是出射光与观察向量的夹角

问题是镜面光的计算，出射光与观察向量的夹角大于90度时，specular表现不正确

## Bling-Phong模型

将Phong模型的镜面光计算改为  入射光与观察向量的一半夹角的那个半程向量Halfway Vector与法线向量的乘积。

# PBR

![20181225202508635](渲染管线.assets/20181225202508635.png)

## PBR核心理论与渲染原理

### 微平面模型

# IBL





# AO

# 图形学数学

## 1. 判断点在三角形内部

点与三个顶点的连线向量，与AB,BC,CA三个边向量，按照顺时针或者逆时针依次叉乘，如果是叉乘结果都是同一个方向的，则点在三角形内部。

计算点与各条边组成的新三角形的面积，如果新三角形的面积大于原三角形，则点不在三角形内。

## 2. 判断光线是否与三角形相交

- 光线与三角形所在面的交点是否落在三角形内
- MT算法，根据重力坐标系，三角形内的点满足$O = \alpha A + \beta B + \gamma C , \alpha + \beta + \gamma = 1$, 光线可以表示为$L = LightPos + t*Direction, t为长度$，假设有交点，则有$(1 - \beta - \gamma  )A + \beta B + \gamma C = LightPos + t*Direction$, 三个未知数，同时根据xyz分别相等列出三个等式，根据克拉默法则，可以得到三个未知数的值，如果三个未知数满足$0<\alpha, \beta,  \gamma <1,t>0$, 则相交。

## 3. 判断两个三角形是否相交

三角形相交则必有某条边与三角形相交，依次判断三角形的三条边是否分别与另一个三角形相交。还是利用MT算法，但是求出的 t 应该在边的长度范围内

## 4. 齐次坐标

二维坐标用三维向量表示，三维向量用四维向量表示，多出的那一维就是齐次坐标，可以看做缩放或者权重。

另外，引入齐次坐标可以通过与矩阵的相乘来表示向量的旋转平移缩放。尤其是平移变换用四维矩阵相乘比用三维矩阵相乘再相加的表示更加简洁高效。



  
