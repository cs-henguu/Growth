# 类相关

## 1. 为什么构造函数不能是虚函数？

因为对象需要在构造函数运行完才能被分配内存空间，即对象的虚表指针才能被创建，对象才可以通过虚表指针找到虚函数的地址，调用相应的虚函数。因此不可能将构造函数定义为虚函数。

错误回答：类需要内存来维护虚函数表，在构造函数之前，类还没有被分配内存空间，所以不能。  很离谱的错误回答，首先不用给一个类分配内存空间，类实例化的对象才需要分配内存空间；其次，虚函数表更不是存放在类的内存中，确切的说，一个类应该被存放在代码段；最后，构造函数是类在实例化时调用的，是对象调用的，而不是类调用的，更不是编译阶段调用的。

不懂装懂最致命！

## 2. 析构函数 虚函数

**析构函数应该被定义为虚函数。**

如果析构函数不是虚函数，由于析构函数是根据指针类型来执行的，那么在销毁基类指针指向的派生类对象时，会只调用基类指针的析构函数，释放派生类对象的基类部分，而派生类新开辟的部分没有被释放，造成内存泄露。

而如果析构函数是虚函数，那么会根据对象类型而非指针类型调用虚函数的析构函数，这样在销毁派生类对象时，会同时执行派生类和基类的析构函数。

# 内存泄露

## 智能指针代码

采用计数原理，用`use_count()`来维护对同一块内存空间的计数，当拷贝构造时，计数+1；重载赋值运算符，将当前指向的原来空间计数-1并判断计数是否为0，当前指向新空间，计数+1；析构函数中判断当前count 是否为0，为0则执行delete，释放内存。

## VS检测内存泄露的代码

加上头文件**#include <crtdbg.h>**

在`main()`函数的最后一行添加`_CtrDumpMemoryLeaks()`函数，调试程序，查看输出即是所有发生内存泄露的地址address；

然后在内存泄露地址处，查看中断，方法是在`main()`第一行添加`_CtrSetBreakAlloc(address)`，意思就是在address处申请中断，在address处查看堆栈。

## 深拷贝和浅拷贝

区别是 是否申请新的堆内存空间

浅拷贝就是对象的数据成员之间的简单赋值。当使用一个对象去直接赋值给另一个对象时，所执行的过程就是浅拷贝。当对象的数据成员中有指针时，会造成两个指针指向同一个内存空间，造成悬挂指针的问题。

因此要使用深拷贝，在堆内存中申请空间来储存数据，做法是该类要提供赋值构造函数。

